# Lock 사용 시 발생할 수 있는 문제점

1. **데드락 (Deadlock)**
   - 데드락은 한 번 발생하면 복구가 거의 불가능하다.
   - 애플리케이션 전체가 완전히 멈춰버릴 수 있다.
   - 코드에 Lock이 많아질수록 데드락이 발생할 확률도 높아진다.

2. **느린 임계 영역 (Slow Critical Section)**
   - 여러 스레드가 하나의 Lock을 기다리고 있는 상황에서, 한 스레드가 Lock을 오래 잡고 있으면 나머지 모든 스레드도 덩달아 느려진다.
   - 즉, 전체 성능이 가장 느린 스레드 수준으로 떨어진다.

3. **우선순위 역전 (Priority Inversion)**
   - 낮은 우선순위의 스레드가 Lock을 잡고 있으면, 높은 우선순위의 스레드가 그 Lock을 기다리며 막혀버린다.
   - 이로 인해 성능 저하 및 응답 속도 감소가 발생할 수 있다.

4. **Lock 해제 실패 (Kill Tolerance)**
   - 스레드가 죽거나, 인터럽트되거나, Lock 해제를 깜빡하면 다른 모든 스레드가 영원히 대기 상태에 빠진다.
   - 이 역시 복구가 불가능하다.
   - 이를 방지하려면 더 복잡한 코드를 작성해야 한다.

5. **성능 오버헤드 (Performance)**
   - 스레드가 Lock을 얻으려다 블로킹되면 컨텍스트 스위칭이 발생하고, 이 과정에서 시간이 소모된다.
   - 일반적인 애플리케이션에서는 크게 체감되지 않을 수 있지만, 지연 시간에 민감한 애플리케이션에서는 이 오버헤드가 심각한 문제가 될 수 있다.

# Lock-Free 기법

**왜 Lock이 필요한가?** → 연산이 원자적(Atomic)이지 않기 때문이다.

**Lock-Free 해결 방법** → 하드웨어 수준에서 하나의 연산으로 보장되는 원자적 연산을 활용한다.
